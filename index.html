<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Tracking Particle Magic - Pro</title>
    
    <style>
        :root {
            --glass: rgba(15, 15, 25, 0.8);
            --border: rgba(255, 255, 255, 0.15);
            --accent: #00f3ff;
            --text: #ffffff;
            --recording: #ff3b3b;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            color: var(--text);
            user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        #input_video {
            position: absolute;
            top: 0; left: 0; width: 0; height: 0;
            opacity: 0; z-index: -1;
        }
        #ui-panel {
            position: absolute;
            top: 20px; left: 20px; width: 300px; padding: 24px;
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-radius: 20px;
            z-index: 20;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            transition: all 0.4s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        #ui-panel.hidden { opacity: 0; transform: translateX(-120%); pointer-events: none; }
        
        h1 { font-size: 16px; margin: 0 0 20px 0; text-transform: uppercase; letter-spacing: 3px; color: var(--accent); display: flex; justify-content: space-between; align-items: center; }
        
        .section-label { font-size: 10px; font-weight: 800; text-transform: uppercase; color: var(--accent); opacity: 0.8; margin: 15px 0 8px 0; letter-spacing: 1px; }

        select, input[type="color"] {
            width: 100%; background: rgba(0,0,0,0.5); border: 1px solid var(--border);
            color: white; padding: 10px; border-radius: 8px; outline: none; font-size: 13px; margin-bottom: 10px;
        }
        
        .toggle-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 13px; }
        
        button {
            width: 100%; padding: 12px; margin-top: 10px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border); color: white; border-radius: 10px;
            cursor: pointer; transition: 0.2s; font-weight: 600; font-size: 13px;
        }
        button:hover { background: var(--accent); color: black; border-color: var(--accent); }

        #btn-record {
            background: rgba(255, 59, 59, 0.1);
            border-color: var(--recording);
            color: var(--recording);
        }
        #btn-record.recording {
            background: var(--recording);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        #ui-toggle {
            position: absolute; top: 20px; left: 20px; z-index: 15;
            background: var(--glass); backdrop-filter: blur(10px);
            border: 1px solid var(--border); color: white; padding: 12px;
            border-radius: 12px; cursor: pointer;
        }

        #instructions {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%); text-align: center;
            z-index: 5; pointer-events: none; width: 95%; display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;
        }
        .instruction-tag {
            background: rgba(0,0,0,0.7); padding: 8px 14px;
            border-radius: 30px; font-size: 11px; border: 1px solid var(--border); letter-spacing: 0.5px;
        }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }

        #share-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #0a0b14; padding: 35px; border-radius: 24px; border: 1px solid var(--accent);
            z-index: 200; display: none; text-align: center; width: 340px; box-shadow: 0 0 100px rgba(0, 243, 255, 0.2);
        }

        #rec-indicator {
            position: absolute; top: 20px; right: 20px; padding: 10px 20px;
            background: var(--recording); color: white; border-radius: 50px;
            font-weight: bold; font-size: 12px; display: none; z-index: 50;
            letter-spacing: 1px;
        }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.2/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <video id="input_video" playsinline muted autoplay></video>
    <div id="canvas-container"></div>
    <div id="rec-indicator">REC 5s...</div>

    <div id="loader">
        <div id="status-text" style="margin-top:20px; font-size: 16px; letter-spacing: 2px;">CALIBRATING UNIVERSE...</div>
        <button id="start-btn" style="display:none; width: auto; padding: 18px 50px; border-radius: 40px; background: var(--accent); color: black; border: none; font-weight: 800; margin-top: 40px;">INITIALIZE EXPERIENCE</button>
    </div>

    <button id="ui-toggle">‚öôÔ∏è</button>
    
    <div id="ui-panel" class="hidden">
        <h1>COSMOS LABS <span id="btn-close-ui" style="cursor:pointer; opacity:0.5;">‚úï</span></h1>
        
        <div class="section-label">Shape Presets</div>
        <select id="shape-selector">
            <option value="galaxy">Galaxy Spiral</option>
            <option value="heart">Love Heart</option>
            <option value="sphere">Quantum Sphere</option>
            <option value="dna">DNA Helix</option>
            <option value="torus">Torus Knot</option>
            <option value="cube">Hyper Cube</option>
            <option value="snow">Snowstorm</option>
            <option value="wave">Wave Form</option>
        </select>

        <div class="section-label">Background</div>
        <select id="bg-selector">
            <option value="black">Black Void</option>
            <option value="space">Starry Deep Space</option>
            <option value="grid">Cyber Grid</option>
            <option value="lights">Northern Lights</option>
            <option value="nebula">Nebula Clouds</option>
        </select>

        <div class="section-label">Color Mode</div>
        <select id="color-mode">
            <option value="dynamic">Rainbow / Velocity</option>
            <option value="gradient">Gradient Map</option>
            <option value="solid">Solid Color</option>
        </select>
        <div style="display:flex; gap:8px;">
            <input type="color" id="color-1" value="#00f3ff">
            <input type="color" id="color-2" value="#ff00aa">
        </div>

        <div class="section-label">Simulation Toggles</div>
        <div class="toggle-item"><span>Auto Rotation</span><input type="checkbox" id="check-rotate" checked></div>
        <div class="toggle-item"><span>Neon Bloom</span><input type="checkbox" id="check-bloom" checked></div>
        <div class="toggle-item"><span>Audio Reactivity</span><input type="checkbox" id="check-audio"></div>
        <div class="toggle-item"><span>Perlin Noise</span><input type="checkbox" id="check-noise" checked></div>
        <div class="toggle-item"><span>Hand Tilt Control</span><input type="checkbox" id="check-tilt" checked></div>
        <div class="toggle-item"><span>Pinch Distortion</span><input type="checkbox" id="check-warp" checked></div>

        <div class="section-label">Export</div>
        <button id="btn-record">Capture 5s Video</button>
        <button id="btn-snap">Take Screenshot</button>
        <button id="btn-share" style="background: #4a4ae2;">Save & Share Link</button>
        <button id="btn-reset">Reset View</button>
    </div>

    <div id="share-modal">
        <h2 style="color:var(--accent); margin-top:0;">Magic Saved!</h2>
        <p style="font-size:13px; opacity:0.7;">Send this link to others:</p>
        <input type="text" id="share-url" readonly style="width: 100%; background:#000; border:1px solid var(--border); color:var(--accent); margin:15px 0; padding:12px; border-radius: 10px; font-size: 12px; font-family: monospace;">
        <button id="btn-copy" style="background: var(--accent); color: black;">Copy Link</button>
        <button id="btn-close-modal" style="background:none; border:none; margin-top:15px; color:#555;">Close</button>
    </div>

    <div id="instructions">
        <span class="instruction-tag">üëÜ Pinch: Black Hole</span>
        <span class="instruction-tag">üëê 2 Hands: Zoom</span>
        <span class="instruction-tag">üìê Tilt Hand: Rotate Universe</span>
        <span class="instruction-tag">üñêÔ∏è Open: Explode</span>
        <span class="instruction-tag">‚úä Fist: Collapse</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBLRlgXxOOYozGySfHNG9owFpmUEG6h84I",
            authDomain: "magic-particles-feaaf.firebaseapp.com",
            projectId: "magic-particles-feaaf",
            storageBucket: "magic-particles-feaaf.firebasestorage.app",
            messagingSenderId: "286909304430",
            appId: "1:286909304430:web:d3b41294165d987c84207f",
            measurementId: "G-GKNK1FD1JY"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = 'cosmic-magic-labs';
        let currentUser = null;

        const state = {
            particleCount: 25000,
            shape: 'galaxy',
            colorMode: 'dynamic',
            color1: new THREE.Color('#00f3ff'),
            color2: new THREE.Color('#ff00aa'),
            autoRotate: true,
            useNoise: true,
            useAudio: false,
            useTilt: true,
            useWarp: true,
            audioLevel: 0,
            recording: false,
            interaction: {
                explosion: 0,
                implosion: 0,
                pinchActive: false,
                pinchPos: new THREE.Vector3(),
                lastPinchDist: 0,
                tiltAngle: 0
            }
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        const warpShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec2 dir = vUv - center;
                    float dist = length(dir);
                    float factor = 1.0 - strength * exp(-dist * 10.0);
                    vec2 uv = center + dir * clamp(factor, 0.5, 1.0);
                    gl_FragColor = texture2D(tDiffuse, uv);
                }`
        };
        const warpPass = new ShaderPass(warpShader);
        composer.addPass(warpPass);

        let analyzer, dataArray;
        function initAudio() {
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                const ctx = new AudioContext();
                const source = ctx.createMediaStreamSource(stream);
                analyzer = ctx.createAnalyser();
                analyzer.fftSize = 256;
                source.connect(analyzer);
                dataArray = new Uint8Array(analyzer.frequencyBinCount);
            }).catch(() => {});
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(state.particleCount * 3);
        const targets = new Float32Array(state.particleCount * 3);
        const colors = new Float32Array(state.particleCount * 3);

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.45,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png')
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        const light1 = new THREE.PointLight(0x00f3ff, 8, 80);
        const light2 = new THREE.PointLight(0xff00aa, 8, 80);
        scene.add(light1, light2);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        function setShape(type) {
            state.shape = type;
            const count = state.particleCount;
            for (let i = 0; i < count; i++) {
                let x, y, z, i3 = i * 3;
                if (type === 'galaxy') {
                    const r = (i / count) * 22, s = i * 0.012 + r * 0.45;
                    x = Math.cos(s) * r; y = (Math.random() - 0.5) * 2.5; z = Math.sin(s) * r;
                } else if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3) * 0.8;
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.8;
                    z = (Math.random() - 0.5) * 4;
                } else if (type === 'sphere') {
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    x = 15 * Math.sin(phi) * Math.cos(theta); y = 15 * Math.sin(phi) * Math.sin(theta); z = 15 * Math.cos(phi);
                } else if (type === 'dna') {
                    const t = (i / count) * Math.PI * 10, h = (i / count) * 40 - 20;
                    const offset = i % 2 === 0 ? 0 : Math.PI;
                    x = Math.cos(t + offset) * 7; z = Math.sin(t + offset) * 7; y = h;
                } else if (type === 'torus') {
                    const u = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 2;
                    x = (12 + 4 * Math.cos(v)) * Math.cos(u); y = (12 + 4 * Math.cos(v)) * Math.sin(u); z = 4 * Math.sin(v);
                } else if (type === 'cube') {
                    x = (Math.random() - 0.5) * 25; y = (Math.random() - 0.5) * 25; z = (Math.random() - 0.5) * 25;
                } else if (type === 'snow') {
                    x = (Math.random() - 0.5) * 80; y = (Math.random() - 0.5) * 80; z = (Math.random() - 0.5) * 80;
                } else if (type === 'wave') {
                    x = (i / count) * 60 - 30; y = Math.sin(x * 0.2) * 10; z = (Math.random() - 0.5) * 20;
                }
                targets[i3] = x; targets[i3+1] = y; targets[i3+2] = z;
                positions[i3] = x; positions[i3+1] = y; positions[i3+2] = z;
            }
            geometry.attributes.position.needsUpdate = true;
        }
        setShape('galaxy');

        let mediaRecorder;
        let recordedChunks = [];

        function getSupportedMimeType() {
            const types = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm', 'video/mp4'];
            for (let type of types) if (MediaRecorder.isTypeSupported(type)) return type;
            return '';
        }

        function startRecording() {
            if (state.recording) return;
            const mimeType = getSupportedMimeType();
            if (!mimeType) return alert("No supported video format");

            state.recording = true;
            recordedChunks = [];

            const btn = document.getElementById('btn-record');
            const indicator = document.getElementById('rec-indicator');
            btn.classList.add('recording');
            btn.innerText = "RECORDING...";
            indicator.style.display = 'block';

            const stream = renderer.domElement.captureStream(60);
            mediaRecorder = new MediaRecorder(stream, { mimeType });

            mediaRecorder.ondataavailable = e => e.data.size > 0 && recordedChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic-capture-${Date.now()}.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
                a.click();

                state.recording = false;
                btn.classList.remove('recording');
                btn.innerText = "Capture 5s Video";
                indicator.style.display = 'none';
            };

            mediaRecorder.start();
            setTimeout(() => mediaRecorder.stop(), 5000);
        }

        let handLandmarker = null;
        const videoElement = document.getElementById('input_video');

        async function initHandLandmarker() {
            const filesetResolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
        }

        let lerpExp = 0, lerpImp = 0;
        function processHands(timestamp) {
            if (!handLandmarker || videoElement.readyState < 2) {
                requestAnimationFrame(processHands);
                return;
            }
            const results = handLandmarker.detectForVideo(videoElement, timestamp);

            state.interaction.explosion = 0;
            state.interaction.implosion = 0;
            state.interaction.pinchActive = false;

            if (results.landmarks && results.landmarks.length > 0) {
                const lm = results.landmarks[0];
                const wrist = lm[0], thumb = lm[4], index = lm[8], middle = lm[12], pinky = lm[20];

                const p = new THREE.Vector3((0.5 - index.x) * 110, (0.5 - index.y) * 80, 0);
                light1.position.lerp(p, 0.25);

                const dPinch = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                const dOpen = Math.hypot(index.x - pinky.x, index.y - pinky.y);
                const dFist = Math.hypot(middle.x - wrist.x, middle.y - wrist.y);

                if (dPinch < 0.045) {
                    state.interaction.pinchActive = true;
                    state.interaction.pinchPos.copy(p);
                }
                if (dOpen > 0.3) state.interaction.explosion = 1.0;
                if (dFist < 0.1) state.interaction.implosion = 1.0;

                if (state.useTilt) {
                    const angle = Math.atan2(index.y - pinky.y, index.x - pinky.x);
                    state.interaction.tiltAngle = angle;
                }

                if (results.landmarks.length === 2) {
                    const h1 = results.landmarks[0][0];
                    const h2 = results.landmarks[1][0];
                    const d = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    if (state.interaction.lastPinchDist > 0) {
                        const delta = (d - state.interaction.lastPinchDist) * 120;
                        camera.position.z = Math.max(10, Math.min(250, camera.position.z - delta));
                    }
                    state.interaction.lastPinchDist = d;
                } else {
                    state.interaction.lastPinchDist = 0;
                }
            }

            requestAnimationFrame(processHands);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if (state.useAudio && analyzer) {
                analyzer.getByteFrequencyData(dataArray);
                let avg = 0;
                for (let i = 0; i < dataArray.length; i++) avg += dataArray[i];
                state.audioLevel = (avg / dataArray.length) / 255;
            }

            lerpExp = THREE.MathUtils.lerp(lerpExp, state.interaction.explosion, 0.08);
            lerpImp = THREE.MathUtils.lerp(lerpImp, state.interaction.implosion, 0.08);

            if (state.useTilt) points.rotation.z = THREE.MathUtils.lerp(points.rotation.z, state.interaction.tiltAngle, 0.05);

            if (state.useWarp && state.interaction.pinchActive) {
                const screen = state.interaction.pinchPos.clone().project(camera);
                warpPass.uniforms.center.value.set(screen.x * 0.5 + 0.5, screen.y * 0.5 + 0.5);
                warpPass.uniforms.strength.value = THREE.MathUtils.lerp(warpPass.uniforms.strength.value, 18.0, 0.1);
            } else {
                warpPass.uniforms.strength.value = THREE.MathUtils.lerp(warpPass.uniforms.strength.value, 0, 0.1);
            }

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            for (let i = 0; i < state.particleCount; i++) {
                const i3 = i * 3;
                pos[i3] += (targets[i3] - pos[i3]) * 0.1;
                pos[i3+1] += (targets[i3+1] - pos[i3+1]) * 0.1;
                pos[i3+2] += (targets[i3+2] - pos[i3+2]) * 0.1;

                if (state.useNoise) {
                    const noise = Math.sin(pos[i3]*0.04 + time*0.4) * (0.15 + state.audioLevel * 12);
                    pos[i3] += noise; pos[i3+1] += noise;
                }

                if (state.interaction.pinchActive) {
                    const d = state.interaction.pinchPos.distanceTo(new THREE.Vector3(pos[i3], pos[i3+1], pos[i3+2]));
                    if (d < 25) {
                        const force = (1 - d/25) * 0.75;
                        pos[i3] += (state.interaction.pinchPos.x - pos[i3]) * force;
                        pos[i3+1] += (state.interaction.pinchPos.y - pos[i3+1]) * force;
                        pos[i3+2] += (state.interaction.pinchPos.z - pos[i3+2]) * force;
                    }
                }

                if (lerpExp > 0.01) { const m = 1 + lerpExp * 0.25; pos[i3]*=m; pos[i3+1]*=m; pos[i3+2]*=m; }
                if (lerpImp > 0.01) { const m = 1 - lerpImp * 0.18; pos[i3]*=m; pos[i3+1]*=m; pos[i3+2]*=m; }

                let c = new THREE.Color();
                if (state.colorMode === 'dynamic') {
                    c.setHSL((time * 0.15 + i/state.particleCount + state.audioLevel) % 1, 0.8, 0.6);
                } else if (state.colorMode === 'gradient') {
                    c.lerpColors(state.color1, state.color2, i/state.particleCount);
                } else {
                    c.copy(state.color1);
                }
                col[i3] = c.r; col[i3+1] = c.g; col[i3+2] = c.b;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            if (state.autoRotate) points.rotation.y += 0.0035;

            controls.update();
            composer.render();
        }

        function updateBackground() {
            const v = document.getElementById('bg-selector').value;
            const colors = {
                black: 0x000000,
                space: 0x050510,
                grid: 0x001111,
                lights: 0x001a0a,
                nebula: 0x0a001a
            };
            renderer.setClearColor(colors[v] || 0x000000);
        }

        async function saveCloud() {
            if (!currentUser) return alert("Please refresh to enable sharing");
            const shareId = Math.random().toString(36).substring(2, 10);
            const data = {
                shape: state.shape,
                bg: document.getElementById('bg-selector').value,
                colorMode: state.colorMode,
                color1: '#' + state.color1.getHexString(),
                color2: '#' + state.color2.getHexString(),
                timestamp: Date.now()
            };
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'shares', shareId), data);
            document.getElementById('share-url').value = window.location.origin + window.location.pathname + "?s=" + shareId;
            document.getElementById('share-modal').style.display = 'block';
        }

        async function loadSharedState() {
            const params = new URLSearchParams(window.location.search);
            const shareId = params.get('s');
            if (!shareId || !currentUser) return;
            const snap = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'shares', shareId));
            if (snap.exists()) {
                const d = snap.data();
                state.shape = d.shape;
                state.colorMode = d.colorMode;
                state.color1.set(d.color1);
                state.color2.set(d.color2);
                document.getElementById('shape-selector').value = d.shape;
                document.getElementById('bg-selector').value = d.bg;
                document.getElementById('color-mode').value = d.colorMode;
                document.getElementById('color-1').value = d.color1;
                document.getElementById('color-2').value = d.color2;
                setShape(d.shape);
                updateBackground();
            }
        }

        document.getElementById('ui-toggle').onclick = () => document.getElementById('ui-panel').classList.toggle('hidden');
        document.getElementById('btn-close-ui').onclick = () => document.getElementById('ui-panel').classList.add('hidden');
        document.getElementById('shape-selector').onchange = e => setShape(e.target.value);
        document.getElementById('bg-selector').onchange = () => updateBackground();
        document.getElementById('color-mode').onchange = e => state.colorMode = e.target.value;
        document.getElementById('color-1').oninput = e => state.color1.set(e.target.value);
        document.getElementById('color-2').oninput = e => state.color2.set(e.target.value);
        document.getElementById('check-rotate').onchange = e => state.autoRotate = e.target.checked;
        document.getElementById('check-bloom').onchange = e => bloomPass.enabled = e.target.checked;
        document.getElementById('check-audio').onchange = e => { state.useAudio = e.target.checked; if (e.target.checked) initAudio(); };
        document.getElementById('check-noise').onchange = e => state.useNoise = e.target.checked;
        document.getElementById('check-tilt').onchange = e => state.useTilt = e.target.checked;
        document.getElementById('check-warp').onchange = e => state.useWarp = e.target.checked;
        document.getElementById('btn-reset').onclick = () => { camera.position.set(0, 0, 50); controls.reset(); points.rotation.set(0,0,0); };
        document.getElementById('btn-record').onclick = startRecording;
        document.getElementById('btn-snap').onclick = () => {
            const link = document.createElement('a');
            link.download = `cosmic-${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL();
            link.click();
        };
        document.getElementById('btn-share').onclick = saveCloud;
        document.getElementById('btn-copy').onclick = () => {
            document.getElementById('share-url').select();
            document.execCommand('copy');
            document.getElementById('btn-copy').innerText = "COPIED!";
            setTimeout(() => document.getElementById('btn-copy').innerText = "Copy Link", 2000);
        };
        document.getElementById('btn-close-modal').onclick = () => document.getElementById('share-modal').style.display = 'none';

        document.getElementById('start-btn').onclick = async () => {
            document.getElementById('loader').style.display = 'none';
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoElement.srcObject = stream;
            await videoElement.play();

            await initHandLandmarker();
            processHands(performance.now());
            animate();
        };

        window.addEventListener('load', async () => {
            await signInAnonymously(auth).catch(() => {});
            onAuthStateChanged(auth, user => { currentUser = user; loadSharedState(); });
            document.getElementById('status-text').innerText = "UNIVERSE STABILIZED.";
            document.getElementById('start-btn').style.display = 'block';
        });

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
